{"name":"Function.prototype.partialApply","tagline":"Being able to partially apply any function in javascript.","body":"## Goal of this post\r\nThe goal of this post is to be able to call any javascript function in a lazy fashion. \r\nFor example, it would mean that if we had a function like:\r\n```javascript\r\nfunction add (x, y, z) {\r\n  return x + y + z;\r\n}\r\n```\r\nWe would like to be able to do the following:\r\n```javascript\r\nvar partialAdd = add(1); // yields a function that needs 2 more arguments\r\nvar result = partialAdd(2, 3);  // yields 6\r\n```\r\nIt means that we can call the function lazily however we want:\r\n```javascript\r\nadd(1, 2, 3); // yields 6\r\nadd(1)(2)(3); // yields 6\r\n```\r\n\r\n## Starting point\r\nWe will start by looking at a function found online [here](http://www.drdobbs.com/open-source/currying-and-partial-functions-in-javasc/231001821?pgno=2). \r\n```javascript\r\nfunction schonfinkelize(fn) {\r\n     var slice = Array.prototype.slice,\r\n        stored_args = slice.call(arguments, 1);\r\n     return function () {\r\n        var new_args = slice.call(arguments),\r\n              args = stored_args.concat(new_args);\r\n        return fn.apply(null, args);\r\n     };\r\n}\r\n```\r\nThis is a interesting function and a good attempt at making functions lazy in javascript. The basic idea of this function is that it takes the original arguments and returns a function that waits for the remaining arguments. You can use it this way:\r\n```javascript\r\nvar addSecondHalf = schonfinkelize(add, 1); // yields a function\r\naddSecondHalf(2, 3); // yields 6 \r\n```\r\nThe issue with this function is that we can't do something like:\r\n```javascript\r\nschonfinkelize(add, 1)(2)(3); // Doesn't work\r\n```\r\nThe reason it doesn't work is because schonfinkelize is not called recursively by looking if we have enough arguments to call the function. In order to make it work, we would have to do something like the following:\r\n```javascript\r\nschonfinkelize(schonfinkelize(add, 1)(2))(3);  // yields 6\r\n```\r\n## The path to the solution\r\nThe first thing we need to think about is how do we know if we have enough arguments to call the function? It turns out javascript has this built-in. Every function in javascript has the attribute length, which returns the number of arguments a function is expecting. So in our case:\r\n```javascript\r\nadd.length  // yields 3\r\n```\r\nWith this information, we know that the base case of our recursive call will be called if we have enough arguments to call the function. With this in mind, let's look at a first solution.\r\n```javascript\r\nfunction partialApply(fn) {\r\n    var slice = Array.prototype.slice;\r\n    var curr_args = slice.call(arguments, 1);\r\n    if(fn.length > curr_args.length) {\r\n    \treturn function() {\r\n    \t\tvar new_args = slice.call(arguments);\r\n    \t\tvar args = curr_args.concat(new_args);\r\n    \t\treturn partialApply.apply(null, [fn].concat(args));\r\n    \t}\r\n    }\r\n    else {\r\n    \treturn fn.apply(null, curr_args);\r\n    }\r\n}\r\n```\r\nSo what does this function do exactly? We recursively call partialApply as long as we don't have enough arguments and the base case is called and we have enough or them. This function allows us to do something like:\r\n```javascript\r\npartialApply(add, 1)(1)(2); // yields 4\r\npartialApply(add)(1)(1)(2); // yields 4\r\npartialApply(add)(1, 1)(2); // yields 4\r\npartialApply(add, 1, 1, 2); // yields 4\r\n```\r\n\r\n## Using the function prototype\r\nThis is great, but it feels awkward to have to pass the function as a parameter, wouldn't it be nice if we could do:\r\n```javascript\r\nadd.partialApply(1)(1)(2); // yields 4\r\nadd.partialApply(1, 1)(2); // yields 4\r\nadd.partialApply(1, 1, 2); // yields 4\r\n```\r\nThe solution is very similar to the above but it will be bound to the function prototype:\r\n```javascript\r\nFunction.prototype.partialApply = function() {\r\n    var fn = this;\r\n    var slice = Array.prototype.slice;\r\n    var curr_args = slice.call(arguments);\r\n    if(fn.length > curr_args.length) {\r\n    \treturn function () {\r\n    \t\tvar new_args = slice.call(arguments);\r\n    \t\tvar args = curr_args.concat(new_args);\r\n    \t\treturn fn.partialApply.apply(fn, args); \r\n    \t}\r\n    }\r\n    else {\r\n    \treturn fn.apply(null, curr_args);\r\n    }\r\n};\r\n```\r\nIn this function, we utlize the fact the javascript functions are first-class objects. In effect, any function is an instance of the Function prototype and therefore will have access to our function partialApply. The \"this\" keyword in javascript refers to the instance calling that function. The base case remains unchanged. \r\nIt gets interesting when we look at the recursive call. The return statement is the following:\r\n```javascript\r\nreturn fn.partialApply.apply(fn, args);\r\n```\r\nWe can't simply call partialApply, we need to apply it because we only have access to the arguments in the form of an array. The other interesting part of this line is that we have to pass in fn as the first argument, since it defined what \"this\" will be in the function call. If we simply did: \r\n```javascript\r\nreturn fn.partialApply.apply(null, args);\r\n```\r\nIt would yield the error (\"Cannot read property 'apply' of undefined\"), since we would not bind this to the right function in the recursive call.\r\n### Usage\r\nSo now, how do I make my functions lazy?\r\nYou can simply call .partialApply() on any function declaration you make. It looks like this.\r\n```javascript\r\nvar add = function(x, y, z) {\r\n    return x + y + z;\r\n}.partialApply();\r\nvar a = add(1, 2, 3); // yields 6\r\nvar b = add(1)(2)(3); // yields 6\r\nvar c = add(1)(2, 3); // yields 6\r\n```\r\nSo this is how you transform any function into a lazy one! \r\n\r\n### Thank you for reading.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}